---
- name: Ensure Certbot is installed.
  ansible.builtin.apt:
    pkg: certbot
    state: present

# @todo - add support for Route 53 DNS plugin
- name: "Ensure certbot-{{ ssl.web_server }} plugin is installed."
  ansible.builtin.apt:
    pkg: "python3-certbot-{{ ssl.web_server }}"
    state: present
  when: ssl.web_server != 'none'

- name: Define SSL base path.
  ansible.builtin.set_fact:
    _ssl_base_path: "/etc/letsencrypt/live"

- name: Add key/cert pairs to know paths information.
  ansible.builtin.set_fact:
    ssl_facts: "{{ ssl_facts | combine({ domain: { 'domain': domain, 'certificate': _ssl_base_path + '/' + domain + '/fullchain.pem', 'key': _ssl_base_path + '/' + domain + '/privkey.pem' } }) }}"
  with_items: "{{ _ssl_domains }}"
  loop_control:
    loop_var: domain

- name: Check if we have a certificate.
  ansible.builtin.stat:
    path: "{{ ssl_facts[_ssl_domains[0]].certificate }}" # it's sufficient to check the first domain for a SAN cert
  register: letsencrypt_cert

- name: Stop services listening on port 80.
  ansible.builtin.service:
    name: "{{ ssl_service }}"
    state: stopped
  with_items: "{{ ssl.services }}"
  loop_control:
    loop_var: ssl_service
  when:
    - not letsencrypt_cert.stat.exists
    - ssl.services is defined

- name: Build certificate domains string.
  ansible.builtin.set_fact:
    _letsencrypt_domain_string: "{{ _letsencrypt_domain_string | default('') + ' -d ' + domain }}"
  with_items: "{{ _ssl_domains }}"
  loop_control:
    loop_var: domain
  when: not letsencrypt_cert.stat.exists

- name: Register certificate if needed.
  ansible.builtin.command: "/usr/bin/certbot certonly -n --cert-name {{ ssl_facts[_ssl_domains[0]].domain }} --http-01-port {{ ssl.http_01_port }} --standalone --preferred-challenges http --agree-tos -m {{ ssl.email }}{{ _letsencrypt_domain_string }}"
  when:
    - not letsencrypt_cert.stat.exists
    - ssl.web_server == 'none'

- name: Register certificate bypassing web server if needed.
  ansible.builtin.command: "/usr/bin/certbot certonly -n --{{ ssl.web_server }} --cert-name {{ ssl_facts[_ssl_domains[0]].domain }} --http-01-port {{ ssl.http_01_port }} --standalone --preferred-challenges http --agree-tos -m {{ ssl.email }}{{ _letsencrypt_domain_string }}"
  when:
    - not letsencrypt_cert.stat.exists
    - ssl.web_server != 'none'

- name: Restart services.
  ansible.builtin.service:
    name: "{{ ssl_service }}"
    state: started
  with_items: "{{ ssl.services }}"
  loop_control:
    loop_var: ssl_service
  when:
    - not letsencrypt_cert.stat.exists
    - ssl.services is defined

# Because of the scripted command each SSL implementation needs it's own uniquely named cron script.
- name: Create the certbot renewal script.
  ansible.builtin.template:
    src: le_cron.sh.j2
    dest: "/usr/local/bin/le_cron_{{ ssl_facts[_ssl_domains[0]].domain | regex_replace('\\.', '_') }}.sh"
    owner: root
    group: root
    mode: 0755
  when: ssl.autorenew

- name: Create cron job for certificate renewal.
  ansible.builtin.cron:
    name: "certbot renewal"
    minute: "{{ ssl.renewal_minute | default('0') }}"
    hour: "{{ ssl.renewal_hour | default('0') }}"
    day: "{{ ssl.renewal_day | default('7') }}"
    job: "/usr/local/bin/le_cron_{{ ssl_facts[_ssl_domains[0]].domain | regex_replace('\\.', '_') }}.sh"
    cron_file: "le_autorenewal_{{ ssl_facts[_ssl_domains[0]].domain | regex_replace('\\.', '_') }}"
    user: root
  when: ssl.autorenew
